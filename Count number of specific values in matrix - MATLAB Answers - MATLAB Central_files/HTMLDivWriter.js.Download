/* Copyright 2017-2020 The MathWorks, Inc. */

define("shared/RichEditor/HTMLDivWriter", [
    "dojo/_base/declare",
    "dojo/dom-class",
    "dojo/dom-construct",
    "dojo/dom-style",
    "dojo/query",
    "rtc/plugins/equations/equationcontroller/view/EquationViewUtilities",
    "rtc/plugins/view/exporters/HTMLContentWriter"
], function (
    declare,
    domClass,
    domConstruct,
    domStyle,
    query,
    EquationViewUtilities,
    HTMLContentWriter
) {

    return declare(HTMLContentWriter, {

        _COMMENT_COLOR: "rgb(0, 128, 19)",
        _KEYWORD_COLOR: "rgb(14, 0, 255)",
        _STRING_COLOR:  "rgb(167, 9, 245)",
        _UNDET_COLOR:   "rgb(144, 38, 34)",
        _SYSCOMMAND_COLOR: "rgb(139, 102, 6)",


        /**
         * Subclass of HTMLContentWriter which produces an HTML DIV element w/o surroundig tags
         * and w/o most inline styles.
         * @constructor HTMLDivWriter
         */
        constructor: function () {

        },

        /**
         * Returns the attributes for the given node, which will be used for creating the HTML tag
         * of the node's content.
         *
         * @returns {String} A list of node attributes.
         */
        _getAttributes: function (node) {

            var classNames = node.className;

            if (node.rteNode) {
                if (node.rteNode.bold) {
                    classNames += " bold";
                }
                if (node.rteNode.italic) {
                    classNames += " italic";
                }
                if (node.rteNode.underline) {
                    classNames += " underline";
                }
                if (node.rteNode.monospace) {
                    classNames += " monospace";
                }
            }

            var styleString = '';
            var style = domStyle.getComputedStyle(node);

            var align = style["text-align"];
            if (align !== "start" && align !== "left") {
                styleString += "text-align" + ": " + style["text-align"] + "; ";
            }

            if (domClass.contains(node, "textWrapper") && style.color !== "rgb(0, 0, 0)") {
                switch(style.color) {
                    case this._COMMENT_COLOR:
                        classNames += " Comment";
                        break;
                    case this._KEYWORD_COLOR:
                        classNames += " Keyword";
                        break;
                    case this._STRING_COLOR:
                        classNames += " String";
                        break;
                    case this._UNDET_COLOR:
                        classNames += " UndetString";
                        break;
                    case this._SYSCOMMAND_COLOR:
                        classNames += " SysCommand";
                        break;

                }
            }

            var attr = ' class="' + classNames + '"';

            if (styleString.length > 0) {
                attr += ' style = "' + styleString + '"';
            }

            return attr;
        },

        /**
         * Overload to write a content DIV and the source within the body
         * @return {string} HTML string
         */
        _write: function () {

            this._writeBody();

            return "<div class = 'rtcContent'>" + this._body + "</div>";

        },

        /*
         * Override to handle symolic outputs.
         */
        _startNodeElement: function (node) {

            if (domClass.contains(node, "outputParagraph")) {
                var eqnsOrig = query(".symbolicElement", node);
                if (eqnsOrig.length > 0) {
                    var clonedNode = node.cloneNode(true);
                    this._replaceEquationsInOutput(clonedNode, node);
                    this._body += clonedNode.outerHTML;
                    return true;
                }
            }

            return this.inherited(arguments);
        },

        /**
         * Checks if outputNode contains symbolic equations, renders those to images
         * using renderer and replaces the MathRoot element by am img element.
         * Replacement is done directly within nodeClone
         *
         * @param nodeClone - The node to manipulate. This must have the same structure as outputNode
         * @param outputNode - The original node that is placed in the dom. This node must exist in
         * the DOM for rendering.  It will not be mutated.
         * @private
         */
        _replaceEquationsInOutput: function (nodeClone, outputNode) {
            var scalingFactor = 2;
            var eqnDataObj, imgSpan;
            var eqnsOrig = query(".symbolicElement", outputNode);
            var eqnsClone = query(".symbolicElement", nodeClone);
            for (var i = 0; i < eqnsOrig.length; i += 1) {
                // The renderer needs the equations placed in the DOM so use the originals
                // instead of the clones for image rendering.
                eqnDataObj = EquationViewUtilities.exportDomnodeToImageURL(eqnsOrig[i], scalingFactor);
                if (eqnDataObj.simpleEquation) {
                    eqnsClone[i].lastChild.innerHTML =
                        EquationViewUtilities.simpleEquationToHTML(eqnDataObj.simpleEquation);
                    continue;
                }

                // create span containing the image for vertical positioning
                imgSpan = domConstruct.create("span", {
                        class: "MathEquation",
                        // Using eqnDataObj.verticalAlign places to high. Use bottom instead.
                        style: {verticalAlign: Math.round(eqnDataObj.verticalAlign) + "px"}
                    },
                    eqnsClone[i].lastChild,
                    "replace"
                );

                // Create the image element and replace the first child (MathRoot) of
                // MathEquation to keep CSS intact.
                domConstruct.create("img", {
                        src: eqnDataObj.dataURL,
                        width: eqnDataObj.width / scalingFactor,
                        height: eqnDataObj.height / scalingFactor
                    },
                    imgSpan
                );
            }
        }

    });
});
